<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAUUSD Nuclear SMC Signal Bot (Twelve Data API)</title>
    <script src="https://cdn.jsdelivr.net/npm/node-fetch@2.6.1/browser.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #1a1a1a; color: #fff; padding: 20px; }
        #status { background: #333; padding: 10px; border-radius: 5px; margin: 10px 0; }
        .signal { background: #4CAF50; padding: 15px; border-radius: 5px; margin: 10px 0; display: none; }
        .error { background: #f44336; }
        input { width: 100%; padding: 10px; margin: 5px 0; border: none; border-radius: 5px; }
        button { background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        #logs { background: #000; color: #0f0; padding: 10px; height: 300px; overflow-y: scroll; font-family: monospace; white-space: pre-line; }
    </style>
</head>
<body>
    <h1>XAUUSD Nuclear SMC Signal Bot (Twelve Data API)</h1>
    <p>Twelve Data se real-time XAU/USD data le raha hai. Free key: twelvedata.com pe sign up karo.</p>
    
    <label>Twelve Data API Key:</label>
    <input type="text" id="twelvekey" placeholder="YOUR_TWELVE_DATA_KEY_HERE (free from twelvedata.com)">
    
    <label>Telegram Bot Token:</label>
    <input type="text" id="token" placeholder="8344115140:AAEiUx-...">
    
    <label>Chat IDs (comma-separated):</label>
    <input type="text" id="chatids" placeholder="123456789,-1001234567890">
    
    <button onclick="startBot()">Start Bot</button>
    <button onclick="stopBot()">Stop Bot</button>
    
    <div id="status">Status: Stopped</div>
    <div id="logs"></div>
    <div id="signal" class="signal"></div>

    <script>
        // =================== CONFIG FOR XAUUSD ===================
        const SYMBOL = "XAU/USD";  // Twelve Data format for Gold
        const SCAN_INTERVAL_MS = 60 * 1000; // 1 min scan
        const MINUTES_15_LIMIT = 200;  // Up to 5000 allowed, but start small
        const H1_LIMIT = 200;
        const H4_LIMIT = 100;
        const VOLUME_SPIKE_MULT = 2.5;
        const MIN_SIGNAL_GAP = 60 * 60 * 1000; // 1 hour cooldown
        const OB_IMBALANCE_THRESHOLD = 0.60;
        // ============================================================

        let lastSignalTime = 0;
        let intervalId = null;
        let isRunning = false;

        function log(msg) {
            const logs = document.getElementById('logs');
            logs.innerHTML += new Date().toLocaleString() + ': ' + msg + '\n';
            logs.scrollTop = logs.scrollHeight;
        }

        function updateStatus(msg, isError = false) {
            const status = document.getElementById('status');
            status.textContent = 'Status: ' + msg;
            status.className = isError ? 'error' : '';
        }

        async function sendTelegram(msgHtml) {
            const token = document.getElementById('token').value.trim();
            if (!token) {
                log('Telegram token not set!');
                return;
            }
            const chatIds = document.getElementById('chatids').value.split(',').map(id => id.trim());
            for (const id of chatIds) {
                if (!id) continue;
                const url = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${id}&text=${encodeURIComponent(msgHtml)}&parse_mode=HTML&disable_web_page_preview=true`;
                try {
                    const res = await fetch(url);
                    const json = await res.json();
                    if (json.ok) log('Signal sent to ' + id);
                    else log('TG Error: ' + JSON.stringify(json));
                    await sleep(300);
                } catch (e) {
                    log('TG Send Failed: ' + e.message);
                }
            }
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // ============ Fetch Klines from Twelve Data API ============
        async function klines(interval, limit = 200) {
            const key = document.getElementById('twelvekey').value.trim();
            if (!key || key.includes('YOUR')) {
                log('Twelve Data API key not set! Sign up at twelvedata.com');
                return [];
            }

            const intervalMap = {
                '15m': '15min',
                '1h': '1h',
                '4h': '4h'
            };
            const intv = intervalMap[interval] || interval;
            const url = `https://api.twelvedata.com/time_series?symbol=${SYMBOL}&interval=${intv}&apikey=${key}&outputsize=${limit}&format=JSON&timezone=UTC`;

            try {
                const r = await fetch(url);
                const data = await r.json();
                if (data.status !== 'ok') {
                    log('API Error: ' + (data.message || 'Unknown error'));
                    return [];
                }
                const values = data.values || [];
                const candles = values.slice(-limit).reverse().map(v => ({
                    t: new Date(v.datetime).getTime(),
                    o: parseFloat(v.open),
                    h: parseFloat(v.high),
                    l: parseFloat(v.low),
                    c: parseFloat(v.close),
                    v: parseFloat(v.volume || 0)  // If no volume, set to 0
                }));
                // Approximate volume if missing (for forex/commodities): use range
                if (candles.some(c => c.v === 0)) {
                    candles.forEach(c => { if (c.v === 0) c.v = (c.h - c.l) * 10000; });
                }
                log(`Fetched ${candles.length} ${interval} candles for XAU/USD from Twelve Data`);
                return candles;
            } catch (e) {
                log('Klines fetch error: ' + e.message);
                return [];
            }
        }

        // ATR Calculation
        function ATR(candles, period = 14) {
            if (candles.length < period + 1) return 0;
            const trs = [];
            for (let i = 1; i < candles.length; i++) {
                const cur = candles[i], prev = candles[i - 1];
                const tr = Math.max(cur.h - cur.l, Math.abs(cur.h - prev.c), Math.abs(cur.l - prev.c));
                trs.push(tr);
            }
            let atr = trs.slice(0, period).reduce((a, b) => a + b, 0) / period;
            for (let i = period; i < trs.length; i++) {
                atr = (atr * (period - 1) + trs[i]) / period;
            }
            return atr;
        }

        // Order Blocks Detection
        function detectOrderBlocks(candles) {
            let bull = null, bear = null;
            for (let i = 5; i < candles.length - 2; i++) {
                const prev = candles[i - 1], cur = candles[i];
                if (prev.c < prev.o && cur.c > cur.o && cur.c > prev.h && cur.l <= prev.l) {
                    bull = { price: prev.l, index: i - 1 };
                }
                if (prev.c > prev.o && cur.c < cur.o && cur.c < prev.l && cur.h >= prev.h) {
                    bear = { price: prev.h, index: i - 1 };
                }
            }
            return { bull, bear };
        }

        // FVG Detection
        function detectFVG(candles) {
            for (let i = 2; i < candles.length; i++) {
                const a = candles[i - 2], x = candles[i];
                if (a.h < x.l) return 'bull';
                if (a.l > x.h) return 'bear';
            }
            return null;
        }

        // Volume Spike Detection
        function isVolumeSpike(candles, mult = VOLUME_SPIKE_MULT) {
            if (candles.length < 10) return false;
            const last = candles[candles.length - 1].v;
            const avg = candles.slice(-10, -1).reduce((s, c) => s + c.v, 0) / 9;
            return last > avg * mult;
        }

        // Trend Bias from 4h
        function trendBiasFrom4h(h4) {
            if (h4.length < 20) return 'neutral';
            const closes = h4.map(c => c.c);
            const sma20 = closes.slice(-21, -1).reduce((a, b) => a + b, 0) / 20;
            const last = closes[closes.length - 1];
            return last > sma20 ? 'bull' : last < sma20 ? 'bear' : 'neutral';
        }

        function fmt(n) { return Number(n).toFixed(2); }

        // Main Scan Function
        async function scan() {
            try {
                const [m15, h1, h4] = await Promise.all([
                    klines('15m', MINUTES_15_LIMIT),
                    klines('1h', H1_LIMIT),
                    klines('4h', H4_LIMIT)
                ]);

                if (!m15.length || m15.length < 20) {
                    log('Not enough data from Twelve Data API');
                    return;
                }

                const price = m15[m15.length - 1].c;
                const atr15 = ATR(m15, 14);
                const ob15 = detectOrderBlocks(m15.slice(-50));
                const ob1h = detectOrderBlocks(h1.slice(-50));
                const fvg = detectFVG(m15.slice(-20));
                const volSpike = isVolumeSpike(m15);
                const bias4h = trendBiasFrom4h(h4 || h1);  // Fallback if needed

                log(`XAU/USD: $${fmt(price)} | Bias: ${bias4h} | VolSpike: ${volSpike ? 'Yes' : 'No'} | FVG: ${fvg || 'None'}`);

                const canLong = ob15.bull && ob1h.bull && fvg === 'bull' && volSpike && bias4h !== 'bear';
                const canShort = ob15.bear && ob1h.bear && fvg === 'bear' && volSpike && bias4h !== 'bull';

                if (Date.now() - lastSignalTime < MIN_SIGNAL_GAP) {
                    if (canLong || canShort) log('Signal blocked by 1h cooldown');
                    return;
                }

                if (canLong || canShort) {
                    const entry = price;
                    const slBuffer = Math.max(atr15 * 1.2, 1.5);
                    const rr = 4.5;
                    let sl, tp;
                    if (canLong) {
                        sl = ob15.bull.price - slBuffer;
                        tp = entry + (entry - sl) * rr;
                    } else {
                        sl = ob15.bear.price + slBuffer;
                        tp = entry - (sl - entry) * rr;
                    }
                    sl = Number(sl.toFixed(2));
                    tp = Number(tp.toFixed(2));

                    const msg = `<b>ü™ô XAUUSD NUCLEAR SMC SIGNAL</b>\n` +
                        `${canLong ? "üî• LONG" : "‚ùÑÔ∏è SHORT"}\n\n` +
                        `Entry: <b>$${fmt(entry)}</b>\nSL: <b>$${fmt(sl)}</b>\nTP: <b>$${fmt(tp)}</b>\nRR: <b>1:${rr}</b>\n\n` +
                        `Setup: OB + FVG + Vol Spike + Bias (${bias4h})\nTime: ${new Date().toLocaleString()}\n\n<i>High RR SMC setup on Gold!</i>`;

                    await sendTelegram(msg);
                    lastSignalTime = Date.now();
                    log(`üöÄ SIGNAL: ${canLong ? 'LONG' : 'SHORT'} @ $${fmt(entry)}`);

                    const signalDiv = document.getElementById('signal');
                    signalDiv.innerHTML = msg.replace(/\n/g, '<br>');
                    signalDiv.style.display = 'block';
                    signalDiv.style.background = canLong ? '#006400' : '#8B0000';
                }
            } catch (e) {
                log('Scan Error: ' + e.message);
                updateStatus('Error in scan', true);
            }
        }

        function startBot() {
            const key = document.getElementById('twelvekey').value.trim();
            if (!key) {
                alert('Twelve Data API key daalo pehle! (twelvedata.com se free key lo)');
                return;
            }
            if (isRunning) return;
            isRunning = true;
            updateStatus('Running with Twelve Data API - XAUUSD Active');
            scan();
            intervalId = setInterval(scan, SCAN_INTERVAL_MS);
            log('Bot started - Nuclear signals incoming!');
        }

        function stopBot() {
            if (intervalId) clearInterval(intervalId);
            isRunning = false;
            updateStatus('Stopped');
            log('Bot stopped');
        }

        // Auto-start on GitHub Pages if keys set
        if (location.hostname.includes('github.io')) {
            setTimeout(() => {
                if (document.getElementById('twelvekey').value && document.getElementById('token').value) {
                    startBot();
                }
            }, 5000);
        }
    </script>
</body>
</html>